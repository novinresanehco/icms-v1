<?php

namespace Tests\Security;

use Tests\TestCase;
use App\Core\Security\SecurityManager;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

class SecurityPenetrationTest extends TestCase
{
    private SecurityManager $security;
    private array $vulnerabilityReport = [];

    protected function setUp(): void
    {
        parent::setUp();
        $this->security = app(SecurityManager::class);
    }

    public function testAuthenticationVulnerabilities(): void
    {
        // 1. Brute Force Protection
        $this->testBruteForceProtection();

        // 2. Session Security
        $this->testSessionSecurity();

        // 3. Token Security
        $this->testTokenSecurity();

        // 4. Password Security
        $this->testPasswordSecurity();

        // Log findings
        $this->logSecurityFindings('authentication');
    }

    private function testBruteForceProtection(): void
    {
        $attempts = [];
        $startTime = microtime(true);

        // Attempt rapid-fire login attempts
        for ($i = 0; $i < 100; $i++) {
            try {
                $response = $this->post('/api/auth/login', [
                    'email' => 'test@example.com',
                    'password' => Str::random(10)
                ]);
                $attempts[] = $response->status();
            } catch (\Exception $e) {
                $attempts[] = $e->getCode();
            }
        }

        // Verify rate limiting
        $this->assertTrue(
            in_array(429, $attempts),
            'Rate limiting not properly enforced'
        );

        // Verify account lockout
        $user = User::where('email', 'test@example.com')->first();
        $this->assertTrue(
            $user->is_locked,
            'Account lockout not triggered'
        );

        // Verify timing consistency
        $endTime = microtime(true);
        $timePerRequest = ($endTime - $startTime) / count($attempts);
        $this->assertGreaterThan(
            0.1,
            $timePerRequest,
            'Potential timing attack vulnerability'
        );
    }

    private function testSessionSecurity(): void
    {
        // Test session fixation
        $beforeLogin = $this->get('/');
        $beforeSessionId = $beforeLogin->headers->getCookie('XSRF-TOKEN');

        $this->post('/api/auth/login', [
            'email' => 'test@example.com',
            'password' => 'password'
        ]);

        $afterLogin = $this->get('/');
        $afterSessionId = $afterLogin->headers->getCookie('XSRF-TOKEN');

        $this->assertNotEquals(
            $beforeSessionId,
            $afterSessionId,
            'Session fixation vulnerability detected'
        );

        // Test session theft
        $originalSession = $this->app['session']->getId();
        $this->withCookie('laravel_session', $originalSession)
             ->withHeader('User-Agent', 'Different Browser')
             ->get('/');

        $this->assertNotEquals(
            $originalSession,
            $this->app['session']->getId(),
            'Session theft protection inadequate'
        );
    }

    private function testTokenSecurity(): void
    {
        // Test CSRF protection
        $response = $this->withoutMiddleware()
                        ->post('/api/content/create', []);
        
        $this->assertEquals(
            419,
            $response->status(),
            'CSRF protection not enforced'
        );

        // Test JWT security
        $token = auth()->attempt([
            'email' => 'test@example.com',
            'password' => 'password'
        ]);

        // Attempt token tampering
        $parts = explode('.', $token);
        $parts[1] = base64_encode('tampered');
        $tamperedToken = implode('.', $parts);

        $response = $this->withHeader('Authorization', "Bearer $tamperedToken")
                        ->get('/api/user');
                        
        $this->assertEquals(
            401,
            $response->status(),
            'Token tampering not detected'
        );
    }

    private function testPasswordSecurity(): void
    {
        // Test password hashing
        $password = 'test_password';
        $hash = Hash::make($password);

        // Verify unique salts
        $anotherHash = Hash::make($password);
        $this->assertNotEquals(
            $hash,
            $anotherHash,
            'Password hashing not using unique salts'
        );

        // Test password complexity requirements
        $weakPasswords = [
            'password',
            '12345678',
            'qwerty123',
            'test@123'
        ];

        foreach ($weakPasswords as $password) {
            $response = $this->post('/api/auth/register', [
                'email' => 'test@example.com',
                'password' => $password
            ]);

            $this->assertEquals(
                422,
                $response->status(),
                'Weak password accepted: ' . $password
            );
        }
    }

    public function testDataSecurity(): void
    {
        // 1. SQL Injection Prevention
        $this->testSQLInjectionPrevention();

        // 2. XSS Prevention
        $this->testXSSPrevention();

        // 3. File Upload Security
        $this->testFileUploadSecurity();

        // 4. Data Encryption
        $this->testDataEncryption();

        // Log findings
        $this->logSecurityFindings('data_security');
    }

    private function testSQLInjectionPrevention(): void
    {
        $injectionAttempts = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "admin'--",
            "'/**/OR/**/1=1"
        ];

        foreach ($injectionAttempts as $attempt) {
            // Test direct query
            try {
                $result = DB::select("SELECT * FROM users WHERE username = ?", [$attempt]);
                $this->assertEmpty($result);
            } catch (\Exception $e) {
                $this->fail('SQL injection prevention failed');
            }

            // Test through API
            $response = $this->get("/api/users?username={$attempt}");
            $this->assertNotEquals(200, $response->status());
        }
    }

    private function testXSSPrevention(): void
    {
        $xssPayloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg/onload=alert(1)>',
            'javascript:alert(1)'
        ];

        foreach ($xssPayloads as $payload) {
            // Test content creation
            $response = $this->post('/api/content', [
                'title' => $payload,
                'body' => $payload
            ]);

            $content = Content::latest()->first();
            $this->assertStringNotContainsString(
                $payload,
                $content->title
            );
            $this->assertStringNotContainsString(
                $payload,
                $content->body
            );

            // Test content rendering
            $rendered = $this->get("/content/{$content->id}");
            $this->assertStringNotContainsString(
                $payload,
                $rendered->getContent()
            );
        }
    }

    private function testFileUploadSecurity(): void
    {
        // Test file type validation
        $maliciousFiles = [
            'test.php' => '<?php echo "hack"; ?>',
            'test.jpg.php' => '<?php echo "hack"; ?>',
            'test.php.jpg' => '<?php echo "hack"; ?>',
            'test.phtml' => '<?php echo "hack"; ?>'
        ];

        foreach ($maliciousFiles as $filename => $content) {
            $response = $this->post('/api/uploads', [
                'file' => $this->createTestFile($filename, $content)
            ]);

            $this->assertEquals(
                422,
                $response->status(),
                "Malicious file accepted: {$filename}"
            );
        }

        // Test file content validation
        $file = $this->createTestFile('test.jpg', '<?php echo "hack"; ?>');
        $response = $this->post('/api/uploads', ['file' => $file]);
        
        $this->assertEquals(
            422,
            $response->status(),
            'Malicious content in valid extension accepted'
        );
    }

    private function testDataEncryption(): void
    {
        // Test data at rest
        $sensitiveData = 'sensitive_info';
        $user = User::factory()->create([
            'secret' => $sensitiveData
        ]);

        // Verify database encryption
        $rawData = DB::table('users')
                    ->where('id', $user->id)
                    ->value('secret');

        $this->assertNotEquals(
            $sensitiveData,
            $rawData,
            'Data not encrypted at rest'
        );

        // Test data in transit
        $response = $this->get('/api/user/' . $user->id);
        $this->assertTrue(
            $response->headers->contains('Content-Security-Policy'),
            'CSP headers not set'
        );
    }

    private function logSecurityFindings(string $category): void
    {
        $this->vulnerabilityReport[$category] = [
            'timestamp' => now(),
            'findings' => $this->getTestResults(),
            'recommendations' => $this->generateRecommendations()
        ];
    }

    private function getTestResults(): array
    {
        return [
            'passed' => $this->getCount('pass'),
            'failed' => $this->getCount('fail'),
            'warnings' => $this->getWarnings(),
            'critical' => $this->getCriticalIssues()
        ];
    }

    private function generateRecommendations(): array
    {
        $recommendations = [];
        foreach ($this->getCriticalIssues() as $issue) {
            $recommendations[] = [
                'issue' => $issue,
                'severity' => 'critical',
                'mitigation' => $this->getMitigationStrategy($issue)
            ];
        }
        return $recommendations;
    }

    private function createTestFile(string $name, string $content): object
    {
        $path = tempnam(sys_get_temp_dir(), 'test_');
        file_put_contents($path, $content);
        return new \Illuminate\Http\UploadedFile(
            $path,
            $name,
            'application/octet-stream',
            null,
            true
        );
    }
}
